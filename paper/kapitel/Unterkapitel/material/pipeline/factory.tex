\subsubsection{Scalability}
\label{subsubsec:scale}
As explained in \fullref{subsec:sources} we have different data sources from which the required data must be retrieved.
For this reason it is extremely important that the architecture needs to be scalable not only in the sense of hardware utilization but also in the sense of implementation effort to add an additional source.
\newline
This is realized by a combination of dynamic programming and a simple \textit{Factory Pattern}\cite{GoF}.
\newline
A so called \textit{collector} is responsible for\textit{Data Ingestion}, while a \textit{transporter} is responsible for transporting and mapping the raw data into \pg{}.
Both \textit{collector} and \textit{transporter} are realized with the factory pattern.
By using the factory pattern we can abstract from the implementation logic which allows to quickly and easily add new data sources to the existing logic without changing anything in the underlying process.
% There are two modules that realize the factory pattern for both collector and transporter:
% \begin{itemize}
%   \item \code{factory.py}
%   \item \code{creator.py}
%   \item \code{collector.py}
%   \item \code{transporter.py}
% \end{itemize}
%
% The module \code{factory.py} contains both the class \code{AbstractFactory}, which is an abstract variant of a concrete factory, and the class
% \code{EverythingFactory} which inherits from the \code{AbstractFactory} and instantiates concrete classes of \code{collector.py} and \code{transporter.py}.
% with help of the \code{creator.py} module.
% This auxiliary class in this module consists of several static methods which create and return an instance of a \textit{collector}/\textit{transporter} instance.
